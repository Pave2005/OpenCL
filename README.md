# Bitonic Sort on OpenCL
## Описание проекта
В этом проекте, была реализована битонной сортировки с помощью OpenCl и проведены ее оптимизации.
Этот проект реализует алгоритм битонной сортировки с использованием OpenCL. [Битонная сортировка](https://en.wikipedia.org/wiki/Bitonic_sorter) — это алгоритм сортировки, хорошо подходящий для распараллеливание и ускорению на GPU. По мере разработки проекта была реализована внутренняя структура работы с библиотекой OpenCL, а также проведено исследование, которое отражает результаты оптимизации алгоритма.

## Локальная и глобальная память в OpenCL

Для понимания различных реализаций алгоритма важно учитывать различия между типами памяти в OpenCL:

- **Глобальная память** — основной и самый большой по объему тип памяти, доступный всем вычислительным элементам. Однако доступ к ней относительно медленный и имеет высокую задержку.
- **Локальная память** — ограниченный по объему, но гораздо более быстрый тип памяти, общий для группы потоков (work-group). Использование локальной памяти позволяет существенно ускорить выполнение алгоритмов, минимизируя обращения к глобальной памяти.
В реализации ```Fast Bitonic Sort``` используется локальная память, что и даёт значительный прирост производительности по сравнению с базовой версией.

## Реализация алгоритма
В проекте реализовано четыре варианта битонной сортировки:

- **Slow Bitonic Sort**
Базовая реализация, использующая только глобальную память GPU.
- **Fast Bitonic Sort**
Оптимизированная версия, использующая локальную память, что значительно снижает затраты на доступ к данным.
- **Parallel CPU Bitonic Sort**
Многопоточная CPU-реализация: массив разбивается на части, каждая из которых сортируется с использованием ```Fast Bitonic Sort```, после чего производится слияние.
- **CPU Bitonic Sort**
Последовательная реализация алгоритма на CPU, без распараллеливания. Подходит для демонстрации принципа работы.

## Оптимизация программы

Наиболее трудоёмкой частью проекта стало изучение работы с локальной памятью OpenCL. Это позволило реализовать версию ```Fast Bitonic Sort```, которая существенно превзошла по производительности базовую реализацию. Также были опробованы различные подходы к оптимизации, включая:

- Предварительную обработку данных;
- Использование локальной памяти;
- Применение многопоточности для ускорения сортировки на CPU.

## Pезультаты и их обсуждение

Для проведения эксперимента было выбрано 3 размера данных: **1024**, **524288** и **67108864**.

### Размер **data_size** = 1024:
Время работы ```std::sort```: 0.035 мс.
| Алгоритм | Время (мс) | Ускорение от ```std::sort``` |
|:----------------:|:------------------------------:|:---------:|
|Slow Bitonic Sort |         1.915        | 0.018       |
|Fast Bitonic Sort |1.867|0.019|
|Parallel CPU Bitonic Sort| 2.752| 0.013|
|CPU Bitonic Sort| 0.134| 0.261|

**Комментарий**: При малом размере данных ```std::sort``` показывает лучшую производительность. Основной причиной являются накладные расходы на инициализацию OpenCL и передачу данных. Сортировка в многопоточном режиме ```Parallel CPU Bitonic Sort``` почти в 1.5 раза медленнее чем ```Fast Bitonic Sort```, что также связано временем работы с OpenCL и потоками. Наилучший же результат показала реализация на одном ядре CPU без использования OpenCL. Bitonic Sort проигрывает как по асимптотике (nlog^2n) , так и по оптимизации стандартной функции.

 Даже несмотря на то, что само ядро ```Fast Bitonic Sort``` выполняется за 0.010 мс, итоговое время значительно выше.

### Размер **data_size** = 524288:
Время работы ```std::sort```: 24.3 мс.
| Алгоритм | Время (мс) | Ускорение от ```std::sort``` |
|:----------------:|:------------------------------:|:---------:|
|Slow Bitonic Sort |         14.9        | 1.6       |
|Fast Bitonic Sort |9.5|2.6|
|Parallel CPU Bitonic Sort| 13.1| 1.9|
|CPU Bitonic Sort| 82.1| 0.3|

**Комментарий**: При увеличении объема данных начинают проявляться преимущества использования GPU. Алгоритм ```Fast Bitonic Sort``` работает в 2.6 раза быстрее, чем ```std::sort```.

### Размер **data_size** = 67108864:
Время работы ```std::sort```: 3.11 с.
| Алгоритм | Время (с) | Ускорение от ```std::sort``` |
|:----------------:|:------------------------------:|:---------:|
|Slow Bitonic Sort |         2.03        | 1.5       |
|Fast Bitonic Sort |1.14|2.7|
|Parallel CPU Bitonic Sort| 1.15| 2.7|
|CPU Bitonic Sort| 14.63| 0.2|

**Обсуждение**: На больших объемах данных ```Fast Bitonic Sort``` демонстрирует наилучший результат, превосходя ```std::sort``` почти в 3 раза. Использование многопоточности на CPU в данном случае не дает дополнительных преимуществ, поскольку основная нагрузка по-прежнему ложится на GPU, а этап слияния добавляет накладные расходы.

## Выводы
Реализация алгоритма ```Bitonic Sort``` с использованием OpenCL позволяет достичь значительного ускорения сортировки на больших массивах данных. Однако эффективность таких решений проявляется только при работе с объемными данными — в малых задачах накладные расходы нивелируют преимущества параллельных вычислений.

По результатам тестов, ускорение до **2.7 раз*** по сравнению с ```std::sort``` делает предложенную реализацию эффективной для задач, требующих высокой производительности при обработке больших объемов данных.

## Ссылки

[https://rutube.ru/video/compute](https://rutube.ru/video/90021891c6dfc628a4ca2a1824c8f429/)

[https://liuyehcf.github.io/resources/paper/Optimizing-parallel-bitonic-sort.pdf](https://liuyehcf.github.io/resources/paper/Optimizing-parallel-bitonic-sort.pdf)

[https://www.geeksforgeeks.org/bitonic-sort/](https://www.geeksforgeeks.org/bitonic-sort/)

[https://en.wikipedia.org/wiki/Bitonic_sorter](https://en.wikipedia.org/wiki/Bitonic_sorter)



# Использование
## Запуск

```sh
mkdir build
cd build
cmake ..
make
./bsort <name of kernel file>
```

 ## Запуск тестов
Тесты запускаются из директории ./build
```sh
ctest
```
