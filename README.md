# Bitonic Sort on OpenCL
## Описание проекта
В этом проекте проводилось исследование и оптимизация битонной сортировки с помощью OpenCl.
Этот проект реализует алгоритм битонной сортировки с использованием OpenCL. [Битонная сортировка](https://en.wikipedia.org/wiki/Bitonic_sorter) — это алгоритм сортировки, хорошо подходящий для распараллеливание и ускорению на GPU. По мере разработки проекта была реализована внутренняя структура работы с библиотекой OpenCL, а также проведено исследование, которое отражает результаты оптимизации алгоритма.

## Реализация алгоритма
Были реализованы четыре алгоритма сортировки:
- **Slow Bitonic Sort**
базовый параллельный алгоритм, работающий на ядрах GPU и использующий только глобальную память.
- **Fast Bitonic Sort**
ускоренная, за счет использования локальной памяти, версия предыдущего алгоритма.
- **Parallel CPU Bitonic Sort**
параллельный алгоритм, работающий на 4 потоках CPU, на каждом из которых с помощью ``` bitonic fast``` сортируются разные куски исходного массива, которые в результате сливаются в один отсортированный массив.
- **CPU Bitonic Sort**
реализация алгоритма сортировки Bitonic Sort без распараллеливания, на одном ядре.

## Оптимизация программы

Самым трудозатратным этапом исследования стало изучение внутренней структуры OpenCL, а именно работы с локальной памятью. Но спустя некоторое количество времени мне удалось реализовать алгоритм **Fast Bitonic Sort**, который дал значительный прирост в эффективности сортировки.

Во время работы было затрачено достаточно много усилий на то, чтобы придумать или найти новые методы оптимизации алгоритма.

Я пробовал разные подходы от подготовке данных перед запуском сортировки, для более эффективного их распределения до использования многопоточного программирования.

## Pезультаты и их обсуждение

Для проведения эксперимента было выбрано 3 размера данных: 1024, 524288 и 67108864.

1)Размер **data_size** = 1024:
Время работы ```std::sort```: 0.035 мс.
| Версия алгоритма | Время работы, мс | Ускорение от ```std::sort``` |
|:----------------:|:------------------------------:|:---------:|
|Slow Bitonic Sort |         1.915        | 0.018       |
|Fast Bitonic Sort |1.867|0.019|
|Parallel CPU Bitonic Sort| 2.752| 0.013|
|CPU Bitonic Sort| 0.134| 0.261|

**Обсуждение**: как можно видеть из данных выше ни один из реализованных алгоритмов не смог обогнать стандартную сортировку на малом количестве данных. Это обусловлено тем, что сортировки реализованные с использованием OpenCL тратят много времени на накладные расходы (например, перегрузка данных), чем и обуставливается результат выше. Сортировка в многопоточном режиме ```Parallel CPU Bitonic Sort``` почти в 1.5 раза медленнее чем ```Fast Bitonic Sort```, что также связано временем работы с OpenCL и потоками. Наилучший же результат показала реализация на одном ядре CPU без использования OpenCL. Bitonic Sort проигрывает как по асимптотике (nlog^2n) , так и по оптимизации стандартной функции.

Также хотелось бы отметить, что время самой сортировки ```Fast Bitonic Sort``` составляет 0.010 мс, что в 3 раза быстрее ```std::sort```, но за счет накладных расходов оно вырастает на порядки.

2)Размер **data_size** = 524288:
Время работы ```std::sort```: 24.3 мс.
| Версия алгоритма | Время работы, мс | Ускорение от ```std::sort``` |
|:----------------:|:------------------------------:|:---------:|
|Slow Bitonic Sort |         14.9        | 1.6       |
|Fast Bitonic Sort |9.5|2.6|
|Parallel CPU Bitonic Sort| 13.1| 1.9|
|CPU Bitonic Sort| 82.1| 0.3|

**Обсуждение**: на данном наборе уже становится виден значительный прирост в скорости сортировки на ядрах GPU. ```Fast Bitonic Sort``` в 2.6 раза быстрее сортирует входные данные, чем ```std::sort```, ей уступает лишь ```CPU Bitonic Sort```, которая, ожидаемо работает медленнее остальных.

3)Размер **data_size** = 67108864:
Время работы ```std::sort```: 3.11 с.
| Версия алгоритма | Время работы, с | Ускорение от ```std::sort``` |
|:----------------:|:------------------------------:|:---------:|
|Slow Bitonic Sort |         2.03        | 1.5       |
|Fast Bitonic Sort |1.14|2.7|
|Parallel CPU Bitonic Sort| 1.15| 2.7|
|CPU Bitonic Sort| 14.63| 0.2|

**Обсуждение**: Наилучший результат показывает ```Fast Bitonic Sort```, которая почти в 3 раза быстрее стандартной сортировки.

**Замечание**: можно заметить, что использование дополнительной многопоточности на CPU не приводит к ускорению сортировки. Это, вероятно связанно с тем, что вычисления в любом случае происходят на одной видеокарте. При этом за счет того, что в конце 4 отсортированных массива необходимо один, затрачивается дополнительное время на работу программы, что нивелирует результат распараллеливания.

## Выводы
С помощью использования вычислений на видеокарте, мне удалось реализовать алгоритм ``` Bitonic Sort ```. Результаты говорят о том, что применение OpenCL и многопоточности эффективно только на больших наборах данных, так как достаточно много затрачивается на накладные расходы, которые в себе хранят параллельные вычисления и работа с памятью. В результате, удалось обогнать ```std::sort``` в ***2.7 раза***, что является достаточно хорошим результатом для данной работы.
